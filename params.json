{"name":"Cinemotion","tagline":"A 2D Engine for the LÖVE2D framework.","body":"#cinemotion\r\n##Abstract\r\ncinemotion is a modular framework to go on top of Löve2D. It is aimed to provide you with the tools you need to rapidly\r\ndevelop games in Löve2D by adding some functionality that love is missing. cinemotions philosophy is to enable you to\r\ndevelop Löve2D games faster and easier but also not to constrain you by forcing a single development style or object\r\nbehaviour on you. To be more specific: cinemotion  won't provide you with a \"tiled\" importer but rather give you the\r\ntools to build one yourself with only a few lines of code. cinemotion tries to follow this strategy of giving you a few\r\nprimitives on which you can start building your game objects.\r\n\r\ncinemotion will further take care of some unpleasant element of game developement you will have to take care of once\r\nyour game gets bigger, such as:\r\n* Asset management\r\n* Collision detection\r\n* Viewport culling\r\n* Scene manegement\r\n\r\ncinemotion was inspired and borrows concepts from various frameworks libraries and game engines, such as the MOAI Framework, jQuery, Construct\r\nand Adventure Game Studio.\r\n\r\n##Set Up\r\n\r\nPut the \"engine\" folder in your love project folder and edit your \"main.lua\" to look like this.\r\n```lua\r\n    ENGINE_PATH = \"engine\" --change if you rename the cinemotion folder\r\n    local engine = require(ENGINE_PATH) --local is optional here\r\n    engine.registerCallbacks() --don't declare your own callback\r\n```\r\nThe engine will run by the scene file \"init.sce\" in the root folder by default.\r\nThis will open a rudementary menu that let's run your own scene files ot change debug settings.\r\nIf you don't want this, you can either edit the \"init.sce\" or change the default scene file to load on start by editing the config.cfg file.\r\nOn windows this will be located in \"C:\\users\\yourname\\AppData\\Roaming\\LOVE\\yourproject\". where yourname is the name you are currently logged on and yourpoject will be the identity of your game set in the \"conf.lua\" with \"t.identity\". If you downloaded the project, this will be \"cinemotion\".\r\n\r\n##Tutorial\r\n\r\n###Getting started\r\n\r\nStart the project like you would usually do with a love project (i.e. on windows: by running \"love.exe foldername\" or putting is into a zip file and renaming the extension to love)\r\n\r\nA simple menu will pop up, that let's your change your settings and run scene files. If you select \"Run Scene\" you will only see one entry, called \"init.sce\". This is the menu screen you're looking at right now.\r\n\r\nThe first important thing to notice here is, that cinemotion organises it's game logic in scenes (you don't have to use them though).\r\nThink of a scene as the biggest distinguishable part of your game. It could be a level or a gui or a menu. So let's create a scene.\r\n\r\n####Our first scene\r\n\r\nCreate a new file in your project root directory.\r\nCall it \"helloworld.sce\" and open it. (TIPP: You can set up your favourite code editor to treat it like a lua file, to get syntax highlighting)\r\n\r\nPaste this into your new file. (TIPP: Some code editors/IDEs let you create templates.)\r\n\r\n```lua\r\n    local cm = require(ENGINE_PATH)\r\n    local scene = {}\r\n\r\n    function scene.onLoad()\r\n        --initialize your scene here\r\n    end\r\n\r\n    function scene.onUpdate()\r\n        --update your scene here.\r\n    end\r\n\r\n    function scene.onStop()\r\n        --define what is going to happen when your scene stops\r\n    end\r\n\r\n    return scene\r\n```\r\n\r\nIf you have worked with love before these function might seem familiar. Like the love functions (e.g. love.load()) these are callbacks for your scenes.\r\nWe can put code in there, to tell our scene what to do at a specific time and state. What is different however is, that these callbacks are all coroutines.\r\nA later chapter might explain this in greater detail for now, just keep in mind that, unlike love's callbacks, you might pause and resume cinemotion callbacks at will.\r\n\r\nGo into the \"scene.onLoad\" function add add the following lines.\r\n```lua\r\n        local layer = cm.layer.new()\r\n        local font = cm.sourceFont.new()\r\n        local text = cm.sprite.new(100,100,font,\"Hello World\")\r\n\r\n        layer:addSprite(text)\r\n```\r\nRun the engine, navigate to run scene and run \"helloworld\"\r\nIf you did everything right, you should see the text \"Hello World\" on screen.\r\n\r\n#####What happened?\r\n\r\nLet's have a closer look at our code.\r\n```lua\r\n    local layer = cm.layer.new()\r\n```\r\nFirst we create a new layer. cm is the local variable we loaded the cinemotion interface at the beginning of the file.\r\n\r\nIf you want cinemotion to put something on screen, you have to put it into a layer first.\r\nIf you ever worked with a picture editing programm like photoshop the concept of layers might be familiar to you.\r\n```lua\r\n    local font = cm.sourceFont.new()\r\n```\r\nNext we create a font. As we supplied no further parameters we will load löve's standart font. Fonts in cinemotion belong to a group of objects in cinemotion called sources. A source is an asset\r\n(which in most cases you load into the game form disk) many game objects (sprites) might share.\r\nThe concept of sources is heavily inspired by moai framework's concepts of decks.\r\nA source can be a sound file, an image, a tileset, a spritesheet, a font and much more. Sources can be shared, e.g. many\r\nin-game sprites might share the same source.\r\n```lua\r\n    local text = cm.sprite.new(100,100,font,\"Hello World\")\r\n    layer:addSprite(text)\r\n```\r\nNow for the actual text on screen. We create a sprite, which is an object, that gets drawn to screen. In the parameters\r\n we first provide the X and Y coordinates for our sprite(100,100), provide a source (font) and provide an Index\r\n (\"Hello World\").\r\n\r\n An Index is, what connects a sprite and a source. Indices may vary depending of the kind of source used. Basically the\r\n index tells the engine what to do with the asset. Different sources take different indices. Fonts generally take strings,\r\n Spritesheets take numerical indices or string-keys depending on how it was constructed, a tileset might take a numerical\r\n index, to just draw a single tile, or a grid object to draw a whole tile layer.\r\n\r\nLast but not least we have to add our sprite into the layer, so the engine can draw it. Thats what the last line does.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}